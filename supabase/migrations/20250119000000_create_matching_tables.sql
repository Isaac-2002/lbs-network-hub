-- Create tables for matching feature
-- Migration: 20250119000000_create_matching_tables.sql

-- Profile summaries (generated by LLM)
CREATE TABLE IF NOT EXISTS profile_summaries (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES profiles(user_id) ON DELETE CASCADE,
  summary_json JSONB NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create index for faster lookups
CREATE INDEX IF NOT EXISTS idx_profile_summaries_user_id ON profile_summaries(user_id);

-- Matches table
CREATE TABLE IF NOT EXISTS matches (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES profiles(user_id) ON DELETE CASCADE,
  matched_user_id UUID REFERENCES profiles(user_id) ON DELETE CASCADE,
  score DECIMAL(3,2) NOT NULL CHECK (score >= 0 AND score <= 1),  -- 0.00 to 1.00
  reason TEXT,
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'accepted', 'declined', 'expired')),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  expires_at TIMESTAMP WITH TIME ZONE,
  UNIQUE(user_id, matched_user_id)
);

-- Create indexes for faster queries
CREATE INDEX IF NOT EXISTS idx_matches_user_id ON matches(user_id);
CREATE INDEX IF NOT EXISTS idx_matches_matched_user_id ON matches(matched_user_id);
CREATE INDEX IF NOT EXISTS idx_matches_status ON matches(status);
CREATE INDEX IF NOT EXISTS idx_matches_created_at ON matches(created_at DESC);

-- Match interactions (for analytics)
CREATE TABLE IF NOT EXISTS match_interactions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  match_id UUID REFERENCES matches(id) ON DELETE CASCADE,
  interaction_type TEXT NOT NULL CHECK (interaction_type IN ('viewed', 'contacted', 'declined')),
  interaction_date TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create index for analytics queries
CREATE INDEX IF NOT EXISTS idx_match_interactions_match_id ON match_interactions(match_id);
CREATE INDEX IF NOT EXISTS idx_match_interactions_type ON match_interactions(interaction_type);

-- Email logs
CREATE TABLE IF NOT EXISTS email_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES profiles(user_id) ON DELETE CASCADE,
  email_type TEXT NOT NULL,
  sent_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  status TEXT DEFAULT 'sent' CHECK (status IN ('sent', 'failed', 'bounced'))
);

-- Create indexes for email logs
CREATE INDEX IF NOT EXISTS idx_email_logs_user_id ON email_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_email_logs_sent_at ON email_logs(sent_at DESC);

-- Row-Level Security Policies

-- Profile summaries: users can only read their own
ALTER TABLE profile_summaries ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can read own profile summary"
  ON profile_summaries FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Service role can manage profile summaries"
  ON profile_summaries FOR ALL
  USING (auth.role() = 'service_role');

-- Matches: users can only see their own matches
ALTER TABLE matches ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can read own matches"
  ON matches FOR SELECT
  USING (auth.uid() = user_id OR auth.uid() = matched_user_id);

CREATE POLICY "Users can update own matches"
  ON matches FOR UPDATE
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Service role can manage matches"
  ON matches FOR ALL
  USING (auth.role() = 'service_role');

-- Match interactions: users can only see their own
ALTER TABLE match_interactions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can read own match interactions"
  ON match_interactions FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM matches
      WHERE matches.id = match_interactions.match_id
      AND (matches.user_id = auth.uid() OR matches.matched_user_id = auth.uid())
    )
  );

CREATE POLICY "Users can create match interactions"
  ON match_interactions FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM matches
      WHERE matches.id = match_interactions.match_id
      AND (matches.user_id = auth.uid() OR matches.matched_user_id = auth.uid())
    )
  );

CREATE POLICY "Service role can manage match interactions"
  ON match_interactions FOR ALL
  USING (auth.role() = 'service_role');

-- Email logs: users can only see their own
ALTER TABLE email_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can read own email logs"
  ON email_logs FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Service role can manage email logs"
  ON email_logs FOR ALL
  USING (auth.role() = 'service_role');

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger for profile_summaries
CREATE TRIGGER update_profile_summaries_updated_at
  BEFORE UPDATE ON profile_summaries
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();
